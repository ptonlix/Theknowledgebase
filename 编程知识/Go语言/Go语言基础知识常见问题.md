# Go语言基础知识常见问题

1.字符串转化为切片[]byte(s)要慎用，尤其是当数据量较大时（每转换一次都需复制内容）

例如：

```go
a := "hello, world!"
b := []byte(a)
```

2.字符串尾部不包含NULL字符，这一点和C/C++不一样

3.Go不支持指针的运算

4.函数允许返回局部变量的地址，Go编译器使用“栈逃逸”机制将这种局部变量的空间分配到堆上。

```Go
func sum (a ,b int) *int {
	sum := a + b 
	return &sum
}
```

5.可以使用range遍历一个map类型变量，但是不保证每次迭代元素的顺序

6.Go内置的map不是并发安全的，并发安全的map可以使用标准包sync中的map

7.不要直接修改map value内某个元素的值，如果想修改map的某个键值，则必须整体赋值。例如：

```go
type User struct {
	name string
	age int
}
ma := make(map[int]User)
andes := User{
	name: "andes",
	age: 18,
}

ma[1] = andes
//ma[1].age = 19 //ERROR, 不能通过map引用直接修改
andes.age = 19

ma[1] = andes //必须整体替换value
fmt.Printf("%v\n", ma)
```

8. struct类型变量初始化，推荐指定field名字的初始化方式，没有指定的字段则默认初始化为类型的零值。

   按照类型声明顺序，逐个赋值（不推荐），一旦struct增加字段，则整个初始化语句会报错

9. if语句

   if后面可以带一个简单的初始化语句，并以分号分割，该简单语句声明的变量的作用域是整个if语句块，包括后面的else if和else分支。

   Go语言没有条件运算符（a>b?a:b），这也符合Go的设计哲学，只提供一种方法做事情。

   **最佳实践：**

   尽量减少条件语句的复杂度，如果语句太多、太复杂，则建议放到函数里面封装起来

   尽量减少if语句的嵌套层次，通过重构代码让代码变得扁平，便于阅读

```go
if err, file := os.Open("xxxx"); err == nil {
    defer file.Close()
    //do something
} else {
    return nil, err
}
//改写后的代码
err, file  := os.Open("xxxx")
if err != nil {
    return nil, err
}
defer file.Close()
//do something
```

10. switch 条件表达式的值不像C语言那样必须限制为整数，可以是任意支持相等比较运算的类型变量

11. 通过fallthough语句来强制执行下一个case子句（不在判断下一个case子句的条件是否满足）

12. Go语言仅支持一种循环语句，即for语句，同样遵循Go的设计哲学，只提供一种方法做事情，把事情做好。

13. 函数如何多值返回值有错误类型，则一般将错误类型作为最后一个返回值

14. Go函数实参到形参的传递永远是值拷贝

15. Go函数支持不定数目的形式参数，不定参数声明使用param ...type的语法格式。

    函数的不定参数有如下几个特点：

    1.所有的不定参数类型必须是相同的

    2.不定参数必须是函数的最后一个参数

    3.不定参数名在函数体内相当于切片，对切片的操作同样适合对不定参数的操作。例如：

    ```
    func sum(arr ...int) (sum int) {
    	for _, v := range arr {
    		sum += v 
    	}
    	return
    }
    ```

    4.切片可以作为参数传递给不定参数，切片名后要加上 “...”。 例如

    ```
    func sum(arr ...int) (sum int) {
    	for _, v:= range arr {
    		sum += v
    	}
    	return
    }
    
    func main() {
    	slice := []int{1, 2, 3, 4}
    	array := [...]int{1, 2, 3, 4}
    
        // 数组不可以作为实参传递给不定参数的函数
        
        sum(slice...)
    }
    ```

    5.形参为不定参数的函数和形参为切片的函数类型不相同。

16. defer 后面必须是函数或者方法的调用，不能是语句，否则会报expression in defer must be function call错误。

17. defer 函数的实参在注册时通过值拷贝传递进去。

18. defer语句必须先注册后才能执行，如果defer位于return之后，则defer因为没有注册，不会执行。

19. 主动调用 os.Exit(int) 推出进程时，defer将不再被执行（即使defer已经提前注册）

20. 在打开资源无报错后直接调用defer关闭资源，一旦养成这样的编程习惯，则很难会忘记资源释放。

21. defer语句的位置不当，有可能导致panic, **一般defer语句放在错误检查语句之后**

22. defer也有明显的副作用：defer会推迟资源的释放，defer尽量不要放到循环语句里面, 将大函数内部的defer语句单独拆分成一个小函数是一个很好的实践方式。

23. 闭包是由函数及其相关引用环境组合而成的实体，一般通过在匿名函数中引用外部函数的局部变量或包全局变量构成。

    ​															闭包=函数+引用环境

    闭包对闭包外的环境引入是直接引用，编译器检测到闭包，会将闭包引用的外部变量分配到堆上。

    如果函数返回的闭包引用了该函数的局部变量（参数或函数内部变量）：

    （1）多次调用该函数，返回的多个闭包所引用的外部变量是多个副本，原因是每次调用函数都会为局部变量分配内存。

    （2）用一个闭包函数多次，如果该闭包函数修改了其引用的外部变量，则每一次调用该闭包对该外部变量都有影响，因为闭包函数共享外部引用。

24. 如果一个函数调用返回的闭包引用修改了全局变量，则每一次调用都会影响全局变量。

25. 使用闭包是为了减少全局变量，所以闭包引用全局变量不是好的编程方式。

26. 对象是附有行为的数据，而闭包是附有数据的行为。类在定义时已经显式地集中定义了行为，但是闭包中的数据没有显式地集中声明的地方，这种数据和行为耦合的模型不是一种推荐的编程模型，闭包仅仅是锦上添花的东西，不是不可缺少的。

27. 错误处理的最佳实践：

    1.在多个返回值的函数中，error通常作为函数最后一个返回值。

    2.如果一个函数返回error类型变量，则先用if语句处理error != nil 的异常场景，正常逻辑放到if语句块后面，保持代码平坦。

    3.defer语句应该放到err判断的后面，不然有可能产生panic

    4.在错误逐级向上传递的过程中，错误信息应该不断地丰富和完善，而不是简单地抛出下层调用的错误。这在错误日志分析时非常有用和友好。

28. 在实际编程中，error和panic的使用应该遵循如下原则：

    1.程序发生的错误导致程序不能容错继续执行，此时程序应该主动调用panic或由运行时抛出panic

    2.程序虽然发生错误，但是程序能够容错继续执行，此时应该使用错误返回值的方式处理错误，或者在可能发生运行时错误的非关键分支上使用recover捕获panic

29. 如果结构初始化语句的 " } “ 独占一行，则最后一个字段的后面一定要带上逗号。